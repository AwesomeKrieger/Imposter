<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<link rel="icon" type="image/png" href="https://raw.githubusercontent.com/AwesomeKrieger/Imposter/refs/heads/main/AppIcon%7Eios-marketing.png">      
<link rel="apple-touch-icon" href="https://raw.githubusercontent.com/AwesomeKrieger/Imposter/refs/heads/main/AppIcon%7Eios-marketing.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <title>IMPOSTER</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
<style>
    :root {
        /* HELLER MODUS */
        --bg-main: #ffffff;
        --bg-card: #ffffff;
        --text-color: #000000;
        --border-color: #000000;
        --item-selected-bg: #000000;
        --item-selected-text: #ffffff;
    }

    /* DARK MODE */
    @media (prefers-color-scheme: dark) {
        :root {
            --bg-main: #000000;
            --bg-card: #000000;
            --text-color: #ffffff;
            --border-color: #ffffff;
            --item-selected-bg: #ffffff;
            --item-selected-text: #000000;
        }
    }

    html, body { 
        background-color: var(--bg-main) !important; 
        color: var(--text-color); 
        margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; 
        transition: background-color 0.3s ease;
    }

    .main-container { 
        height: 100dvh; 
        display: flex; 
        flex-direction: column; 
        padding: 1rem; 
        box-sizing: border-box;
        background-color: var(--bg-main);
    }

    .game-card { 
        background-color: var(--bg-card);
        border: 4px solid var(--border-color) !important;
        display: flex; flex-direction: column; height: 100%; overflow: hidden; 
        box-shadow: 6px 6px 0px 0px var(--border-color);
    }

   .topics-block-container {
    margin: 10px 0;
    border: 4px solid var(--border-color);
    background: var(--bg-card);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 6px 6px 0px 0px var(--border-color);
}

.scroll-container { 
    flex: 1;
    max-height: 280px; /* Begrenzt die H√∂he des Kastens */
    overflow-y: auto !important; 
    background: var(--bg-card); 
    padding: 0 !important;
    display: flex;
    flex-direction: column;
}

.category-item {
    margin: 0 !important;
    padding: 16px; 
    background: var(--bg-card);
    color: var(--text-color);
    border: none !important;
    /* Standardm√§√üig eine dunkle Linie oben zur Trennung */
    border-top: 2px solid var(--border-color) !important; 
    cursor: pointer;
    text-align: left;
    font-weight: 900;
    text-transform: uppercase;
    width: 100% !important;
    box-sizing: border-box;
}

/* WICHTIG: Wenn ausgew√§hlt -> Schwarz mit HELLEM Rand */
.category-item.selected {
    background-color: var(--item-selected-bg) !important;
    color: var(--item-selected-text) !important;
    /* Erzeugt die helle Trennung zwischen zwei schwarzen Bl√∂cken */
    border-top: 2px solid rgba(255, 255, 255, 0.3) !important; 
}

/* Verhindert eine wei√üe Linie beim allerersten Element im Kasten */
.category-item:first-child {
    border-top: none !important;
}


    input, select {
        background-color: var(--bg-card) !important;
        color: var(--text-color) !important;
        border: 2px solid var(--border-color) !important;
    }

    .hide-scrollbar::-webkit-scrollbar { display: none; }
</style>


</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        const GITHUB_TOPICS_URL = "https://raw.githubusercontent.com/AwesomeKrieger/Imposter/main/topics.json";
        const AI_MODEL = "gemini-2.5-flash-lite"; 


        const App = () => {
            const [data, setData] = useState(null);
            const [aiWordPool, setAiWordPool] = useState(() => {
                const saved = localStorage.getItem('imp_word_pool_v1');
                return saved ? JSON.parse(saved) : {};
            });

            const [groups, setGroups] = useState([]);
            const [selectedGroup, setSelectedGroup] = useState("BELIEBT");
            const [subCats, setSubCats] = useState([]);
            const [selectedSubs, setSelectedSubs] = useState([]);
            
            const [gameState, setGameState] = useState('setup'); 
            const [shuffledBeliebt, setShuffledBeliebt] = useState([]);
            const [players, setPlayers] = useState(['Spieler 1', 'Spieler 2', 'Spieler 3']);
            const [imposterCount, setImposterCount] = useState(1);
            const [showHint, setShowHint] = useState(false);
            const [timerMinutes, setTimerMinutes] = useState(0);
            const [timeLeft, setTimeLeft] = useState(0);
            const [stats, setStats] = useState({});

            const [apiKey, setApiKey] = useState(() => localStorage.getItem('imp_key') || '');
            const [customTopics, setCustomTopics] = useState(() => {
                const saved = localStorage.getItem('imp_custom_v12');
                return saved ? JSON.parse(saved) : [];
            });
            
            const [loading, setLoading] = useState(false);
            const [visualProgress, setVisualProgress] = useState(0);
            const [gameData, setGameData] = useState({ word: "", hint: "", imposterIndices: [], currentPlayer: 0, showingWord: false, chaosMode: "" });
            const [deleteConfirm, setDeleteConfirm] = useState(null);

const triggerDelete = (e, name) => {
    e.preventDefault();
    e.stopPropagation();
    setDeleteConfirm(name);
};
const getFontSize = (text) => {
    if (!text) return 'text-5xl';
    const len = text.length;
    if (len > 15) return 'text-xl';
    if (len > 12) return 'text-2xl';
    if (len > 9) return 'text-3xl';
    if (len > 6) return 'text-4xl';
    return 'text-5xl';
};



const confirmDelete = () => {
    const newList = customTopics.filter(t => t.name !== deleteConfirm);
    setCustomTopics(newList);
    localStorage.setItem('imp_custom_v12', JSON.stringify(newList));
    
    // HIER DIE KORREKTUR: Mit Prefix filtern
    setSelectedSubs(prev => prev.filter(id => id !== `EIGENE:${deleteConfirm}`));
    
    setSubCats(newList.map(t => ({ name: t.name, parent: "EIGENE" })));
    setDeleteConfirm(null);
};



            useEffect(() => {
    fetch(GITHUB_TOPICS_URL)
        .then(res => res.json())
        .then(json => {
            setData(json);
            setGroups(["BELIEBT", "EIGENE", ...Object.keys(json)]);
            
            // Initialisiert die "Beliebt"-Liste mit dem aktuellen 3h-Slot
            const initial = getShuffledBeliebt(json);
            setShuffledBeliebt(initial);
            
            // Setzt die Ansicht standardm√§√üig auf diese gew√ºrfelten Themen
            setSubCats(initial); 
        })
        .catch(err => console.error("Fehler beim Laden der Themen:", err));
}, []);



            useEffect(() => {
                localStorage.setItem('imp_word_pool_v1', JSON.stringify(aiWordPool));
            }, [aiWordPool]);

            // Hilfsfunktion zum W√ºrfeln (bleibt stabil)
// Hilfsfunktion zum stabilen W√ºrfeln (√§ndert sich alle 3 Stunden)
const getShuffledBeliebt = (fullData) => {
    if (!fullData) return [];
    let list = [];
    Object.keys(fullData).forEach(g => {
        Object.keys(fullData[g]).forEach(s => list.push({ name: s, parent: g }));
    });

    // Erzeugt einen Zeit-String, der f√ºr 3 Stunden gleich bleibt (z.B. "2026-02-13-Slot6")
    const now = new Date();
    const datePart = now.toISOString().split('T')[0];
    const timeSlot = Math.floor(now.getHours() / 3); 
    const seedString = datePart + "-slot" + timeSlot;

    // Einfache Seeded-Random Funktion (Pseudo-Zufall)
    const seededRandom = (str) => {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        // Normalisiert den Hash auf einen Wert zwischen 0 und 1
        return Math.abs(Math.sin(hash));
    };

    // Wir sortieren die Liste basierend auf dem Seed + dem Namen des Themas
    return list
        .sort((a, b) => seededRandom(seedString + a.name) - seededRandom(seedString + b.name))
        .slice(0, 6); // Zeigt 5 beliebte Themen
};


const updateView = (groupName, fullData = data, currentCustom = customTopics) => {
    if (!fullData) return;
    setSelectedGroup(groupName);
    
    if (groupName === "BELIEBT") {
        setSubCats(shuffledBeliebt); // Nutzt die gespeicherten Favoriten
    } else if (groupName === "EIGENE") {
        setSubCats(currentCustom.map(t => ({ name: t.name, parent: "EIGENE" })));
    } else {
        const list = [];
        Object.keys(fullData[groupName]).forEach(s => list.push({ name: s, parent: groupName }));
        setSubCats(list);
    }
};




            const toggleSub = (name, parent) => {
    const id = `${parent}:${name}`; 
    setSelectedSubs(prev => 
        prev.includes(id) ? prev.filter(n => n !== id) : [...prev, id]
    );
};

const selectAll = () => {
    const currentIds = subCats.map(s => `${s.parent}:${s.name}`);
    const allCurrentSelected = currentIds.every(id => selectedSubs.includes(id));
    if (allCurrentSelected) {
        setSelectedSubs(prev => prev.filter(id => !currentIds.includes(id)));
    } else {
        setSelectedSubs(prev => [...new Set([...prev, ...currentIds])]);
    }
};

const handleGlobalToggle = () => {
    if (selectedSubs.length > 0) {
        setSelectedSubs([]);
    } else {
        let allIds = [];
        Object.keys(data).forEach(group => {
            if (group !== "BELIEBT") { // Beliebt √ºberspringen, da es nur Kopien sind
                Object.keys(data[group]).forEach(sub => {
                    allIds.push(`${group}:${sub}`);
                });
            }
        });
        customTopics.forEach(t => allIds.push(`EIGENE:${t.name}`));
        setSelectedSubs(allIds);
    }
};



            const addCustomTopic = () => {
    const name = prompt("Gib ein Thema f√ºr die KI ein:");
    if(name && name.trim() !== "") {
        const trimmedName = name.trim();
        const newList = [...customTopics, { name: trimmedName }];
        setCustomTopics(newList);
        localStorage.setItem('imp_custom_v12', JSON.stringify(newList));
        
        const newSubList = newList.map(t => ({ name: t.name, parent: "EIGENE" }));
        setSubCats(newSubList);
        
        // HIER DIE KORREKTUR: Prefix hinzuf√ºgen
        setSelectedSubs(prev => [...prev, `EIGENE:${trimmedName}`]);
    }
};

const startGame = async () => {
    let finalId = "";

    if (selectedSubs.length === 0) {
        // Sammle ALLE verf√ºgbaren Themen-IDs
        const allPossibleIds = [];
        
        Object.keys(data).forEach(group => {
            if (group !== "BELIEBT") { 
                Object.keys(data[group]).forEach(sub => {
                    allPossibleIds.push(`${group}:${sub}`);
                });
            }
        });
        
        customTopics.forEach(t => allPossibleIds.push(`EIGENE:${t.name}`));

        // W√§hle eine absolut zuf√§llige ID aus der Gesamtliste
        finalId = allPossibleIds[Math.floor(Math.random() * allPossibleIds.length)];
    } else {
        // W√§hle aus deiner Auswahl
        finalId = selectedSubs[Math.floor(Math.random() * selectedSubs.length)];
    }

    if (!finalId) return alert("Keine Themen verf√ºgbar!");

    const [parentGroup, randomSub] = finalId.split(':');

    setLoading(true);
    setVisualProgress(50);
    
    let word = "", hint = "", chaos = "";
    let indices = [];
    


    try {
        
 
        const rng = Math.random();
        if (rng < 0.01) chaos = "ALL";
        else if (rng < 0.02) chaos = "NONE";

        // 3. Nutzt jetzt 'parentGroup', um zu entscheiden: KI oder Liste?
        if (parentGroup === "EIGENE") {
            if(!apiKey) {
                setLoading(false);
                return alert("API Key fehlt!");
            }
            
            if (aiWordPool[randomSub] && aiWordPool[randomSub].length > 0) {
                const nextPair = aiWordPool[randomSub][0];
                word = nextPair.word;
                hint = nextPair.hint;
                setAiWordPool(prev => ({ ...prev, [randomSub]: prev[randomSub].slice(1) }));
            } else {
               

                                                                                               // Der Prompt ist jetzt extrem strikt
                const promptText = `Generiere 40 unterschiedliche Wort-Paare f√ºr das Spiel Tabu zum Thema "${randomSub}".
                Regel: Antworte NUR im Format Wort|Hinweis, Wort|Hinweis.
                Keine Einleitung, keine Nummerierung, kein Thema wiederholen.
                Beispiel: Apfel|Obst, Baum|Blatt.`;
                
                const res = await fetch("https://api.groq.com/openai/v1/chat/completions", {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "llama-3.1-8b-instant",
                        messages: [
                            { role: "system", content: "Du bist eine Wort-Generator-Maschine. Du gibst nur Wort-Listen aus." },
                            { role: "user", content: promptText }
                        ],
                        temperature: 0.8,
                        max_tokens: 2000 // Genug Platz f√ºr 40 W√∂rter
                    })
                });

                const d = await res.json();
                if (d.error) { alert(`Groq-Fehler: ${d.error.message}`); return; }

                let raw = d.choices[0].message.content.trim();
                
                // Wir s√§ubern die Antwort von Zeilenumbr√ºchen und seltsamen Zeichen
                raw = raw.replace(/\n/g, ", ").replace(/\d+\./g, "");

                const pairs = raw.split(',').map(p => {
                    const parts = p.split('|');
                    if (parts.length < 2) return null;
                    
                    const w = parts[0].trim();
                    const h = parts[1].trim();

                    // Verhindert, dass das Kategoriewort selbst als Wort gew√§hlt wird
                    if (w.toLowerCase() === randomSub.toLowerCase() || w.length < 2) return null;
                    
                    return { word: w, hint: h };
                }).filter(p => p !== null);

                if (pairs.length > 0) {
                    word = pairs[0].word;
                    hint = pairs[0].hint;
                    setAiWordPool(prev => ({ ...prev, [randomSub]: pairs.slice(1) }));
                } else {
                    alert("Die KI hat kein g√ºltiges Listen-Format geliefert. Antwort war: " + raw.substring(0, 50));
                }
            }


        } else {
            // FIX: Suche global in allen Kategorien von 'data'
            let foundData = null;
            for (let groupKey in data) {
                if (data[groupKey] && data[groupKey][randomSub]) {
                    foundData = data[groupKey][randomSub];
                    break;
                }
            }

            if (foundData && foundData.pairs && foundData.pairs.length > 0) {
                const randomPair = foundData.pairs[Math.floor(Math.random() * foundData.pairs.length)];
                word = randomPair[0];
                hint = randomPair[1];
            }
        }

        if (!word) {
            throw new Error("Wort konnte nicht geladen werden. Thema: " + randomSub);
        }

        if (chaos === "ALL") {
            indices = players.map((_, i) => i);
        } else if (chaos === "NONE") {
            indices = [];
        } else {
            const count = Math.min(imposterCount, players.length - 1);
            while(indices.length < count) {
                let r = Math.floor(Math.random() * players.length);
                if(!indices.includes(r)) indices.push(r);
            }
        }

        const newStats = { ...stats };
        indices.forEach(idx => { newStats[players[idx]] = (newStats[players[idx]] || 0) + 1; });
        setStats(newStats);
        // √Ñndere diese Zeile in deinem Skript:
setGameData({ word, hint, imposterIndices: indices, currentPlayer: 0, showingWord: false, chaosMode: chaos, topic: randomSub });
        setTimeLeft(timerMinutes * 60);
        setVisualProgress(100);
        setTimeout(() => { setGameState('reveal'); setLoading(false); }, 400);
    } catch (e) { 
        console.error(e);
        alert("Fehler: " + e.message); 
        setLoading(false); 
    }
};


            const formatTime = (s) => `${Math.floor(s/60)}:${(s%60).toString().padStart(2, '0')}`;

            if (!data) return <div className="h-screen flex items-center justify-center font-black">Lade...</div>;

            return (
                <div className="main-container">
                    <h1 className="text-4xl font-black italic mb-4 border-b-8 border-red-600 tracking-tighter shrink-0 uppercase">Imposter.ai</h1>

                    <div className="game-card bg-white p-5 neo-box space-y-4">
                        {loading ? (
                             <div className="flex flex-col items-center justify-center p-10 space-y-4">
                                <div className="font-black text-xl italic uppercase">Generiere...</div>
                                <div className="w-full border-4 border-black h-8 bg-white"><div className="progress-fill" style={{width: `${visualProgress}%`}}></div></div>
                            </div>
                        ) : gameState === 'setup' ? (
                            <>
                                <div className="grid grid-cols-3 gap-2 shrink-0">
                                    <div className="space-y-1">
                                        <label className="text-[10px] font-black uppercase opacity-60">Verr√§ter:</label>
                                        <select value={imposterCount} onChange={e => setImposterCount(parseInt(e.target.value))} className="w-full p-2 border-2 border-black font-bold text-xs bg-white outline-none">
                                            {Array.from({length: players.length - 1}, (_, i) => i + 1).map(n => <option key={n} value={n}>{n}</option>)}
                                        </select>
                                    </div>
                                    <div className="space-y-1">
                                        <label className="text-[10px] font-black uppercase opacity-60">Hinweis:</label>
                                        <button onClick={() => setShowHint(!showHint)} className={`w-full p-2 border-2 border-black font-bold text-[10px] uppercase transition-colors ${showHint ? 'bg-green-400' : 'bg-red-400'}`}>
                                            {showHint ? 'AN' : 'AUS'}
                                        </button>
                                    </div>
                                    <div className="space-y-1">
                                        <label className="text-[10px] font-black uppercase opacity-60">Zeitlimit:</label>
                                        <select value={timerMinutes} onChange={e => setTimerMinutes(parseInt(e.target.value))} className="w-full p-2 border-2 border-black font-bold text-xs bg-white outline-none">
                                            {[0,1,2,3,5,10].map(m => <option key={m} value={m}>{m === 0 ? "AUS" : `${m}min`}</option>)}
                                        </select>
                                    </div>
                                </div>

                                <div className="space-y-2 pt-2 shrink-0">
                                    <div className="flex justify-between items-center">
                                        <span className="font-black text-[10px] uppercase underline">Mitspieler:</span>
                                        <button onClick={() => players.length < 10 && setPlayers([...players, `Spieler ${players.length+1}`])} className="bg-green-500 text-white px-2 py-1 neo-box text-[10px] font-black uppercase">+ Add</button>
                                    </div>
                                    <div className="grid grid-cols-2 gap-1 max-h-24 overflow-y-auto border border-black p-1 bg-gray-50">
                                        {players.map((p, i) => (
                                            <div key={i} className="flex border border-black bg-white">
                                                <input value={p} onChange={e => {let n=[...players]; n[i]=e.target.value; setPlayers(n);}} className="w-full p-1 text-[10px] font-bold outline-none uppercase" />
                                                <span className="text-[9px] font-black bg-yellow-400 px-1 border-l border-black flex items-center">üïµÔ∏è{stats[p] || 0}</span>
                                                <button onClick={() => players.length > 3 && setPlayers(players.filter((_, idx) => idx !== i))} className="bg-red-500 text-white px-1 font-black">√ó</button>
                                            </div>
                                        ))}
                                    </div>
                                </div>

                                <div className="flex gap-2 overflow-x-auto pb-2 hide-scrollbar border-t-2 border-black pt-2 shrink-0">
                                    {groups.map(g => {
    let hasSelection = false;
    let countInGroup = 0;

    if (g === "BELIEBT") {
        // Pr√ºft, welche der aktuell angezeigten Favoriten-Themen ausgew√§hlt sind
        const beliebtIds = shuffledBeliebt.map(s => `${s.parent}:${s.name}`);
        countInGroup = selectedSubs.filter(id => beliebtIds.includes(id)).length;
        hasSelection = countInGroup > 0;
    } else {
        // Pr√ºft alle anderen Gruppen (SPORT, EIGENE, etc.)
        hasSelection = selectedSubs.some(id => id.startsWith(`${g}:`));
        countInGroup = selectedSubs.filter(id => id.startsWith(`${g}:`)).length;
    }

    return (
        <button 
            key={g} 
            onClick={() => updateView(g)} 
            className={`px-3 py-2 border-2 border-black font-black text-[10px] uppercase whitespace-nowrap transition-all 
                ${selectedGroup === g ? 'bg-red-600 text-white' : (hasSelection ? 'bg-yellow-300 text-black' : 'bg-white text-black')}`}
        >
            {g} {hasSelection && `(${countInGroup})`}
        </button>
    );
})}

                                </div>

                                <div className="topics-block-container mx-0 my-2">
    {/* Buttons b√ºndig oben im Kasten */}
    <div className="flex shrink-0 bg-transparent border-b-4 border-black dark:border-white">
        <button 
            onClick={selectAll} 
            className="flex-1 p-3 bg-yellow-400 font-black text-[10px] uppercase !text-black border-r-4 border-black dark:border-white active:bg-yellow-500 transition-colors"
        >
            {subCats.length > 0 && subCats.every(s => selectedSubs.includes(s.name)) ? "√ó Abw√§hlen" : "‚úì Gruppe"}
        </button>

        <button 
    onClick={handleGlobalToggle} 
    className={`w-1/3 p-3 font-black text-[10px] uppercase transition-colors ${
        selectedSubs.length > 0 ? 'bg-red-500 text-white' : 'bg-blue-500 text-white'
    }`}
>
    {selectedSubs.length > 0 ? `Reset (${selectedSubs.length})` : "Global"}
</button>

    </div>

    {/* Themenliste direkt darunter im selben Geh√§use */}
    <div className="scroll-container hide-scrollbar" style={{ maxHeight: '300px' }}>
        {selectedGroup === "EIGENE" && (
            <button 
                onClick={addCustomTopic} 
                className="w-full p-4 border-b-4 border-dashed border-black dark:border-white font-black text-sm uppercase bg-yellow-100 !text-black shrink-0"
            >
                + NEUES KI-THEMA
            </button>
        )}
        
        {subCats.map((s) => {
    const currentId = `${s.parent}:${s.name}`; // Nutzt jetzt den echten Ursprung
    const isSelected = selectedSubs.includes(currentId);
    return (
        <button 
            key={currentId}
            type="button"
            onClick={() => toggleSub(s.name, s.parent)} 
            className={`category-item ${isSelected ? 'selected' : ''}`}
        >
            <div className="flex justify-between items-center w-full">
                <span>{isSelected ? "‚úì " : ""}{s.name}</span>
                {selectedGroup === "EIGENE" && (
                    <span 
                        onClick={(e) => { e.stopPropagation(); triggerDelete(e, s.name); }} 
                        className="text-[10px] bg-red-600 px-2 py-1 text-white border-2 border-white font-black"
                    >
                        L√ñSCHEN
                    </span>
                )}
            </div>
        </button>
    );
})}

    </div>
</div>







                                <button onClick={startGame} className="w-full bg-red-600 text-white font-black py-4 text-2xl neo-box shrink-0 active:bg-red-700 uppercase">
                                    {selectedSubs.length > 0 ? `Start (${selectedSubs.length})` : 'Zuf√§lliges Thema'}
                                </button>

                                <input type="password" placeholder="API Key..." className="w-full p-1 text-[8px] border-b opacity-10 shrink-0" value={apiKey} onChange={e => {setApiKey(e.target.value); localStorage.setItem('imp_key', e.target.value);}} />
                            </>                                                 ) : (
                            <div className="p-4 text-center">
                                {gameState === 'reveal' && (
                                    <div className="space-y-6 py-4 flex flex-col items-center">
                                        <h2 className="text-2xl font-black uppercase italic border-b-4 border-black px-4">
                                            {players[gameData.currentPlayer]}
                                        </h2>
                                        
                                        <div onClick={() => setGameData({...gameData, showingWord: true})} 
                                             className={`w-full h-64 flex flex-col items-center justify-center border-4 border-black p-6 
                                             ${gameData.showingWord 
                                                ? (gameData.imposterIndices.includes(gameData.currentPlayer) ? 'bg-black text-white' : 'bg-red-600 text-white') 
                                                : 'bg-gray-100 animate-pulse'}`}>
                                            
                                            {gameData.showingWord ? (
                                                gameData.imposterIndices.includes(gameData.currentPlayer) ? (
                                                    <div className="text-center">
                                                        <div className="text-red-500 font-black text-xl mb-1 uppercase tracking-widest">Du bist der</div>
                                                        <div className="text-6xl font-black uppercase italic">Imposter</div>
                                                        {showHint && <div className="mt-6 p-3 border-2 border-white text-sm font-bold uppercase tracking-tight">Tipp: {gameData.hint}</div>}
                                                    </div>
                                                ) : (
                                                    <span className={`${getFontSize(gameData.word)} font-black uppercase tracking-tighter text-center break-words w-full px-2`}>
                                                        {gameData.word}
                                                    </span>
                                                )
                                            ) : (
                                                <span className="text-2xl font-black italic underline uppercase text-black">Karte aufdecken</span>
                                            )}
                                        </div>

                                        {gameData.showingWord && (
                                            <button onClick={() => {
                                                if(gameData.currentPlayer + 1 < players.length) {
                                                    setGameData({...gameData, currentPlayer: gameData.currentPlayer + 1, showingWord: false});
                                                } else {
                                                    setGameState('play');
                                                }
                                            }} className="w-full bg-black text-white py-4 font-black text-xl neo-box uppercase">
                                                Verstanden
                                            </button>
                                        )}
                                    </div>
                                )}

                                {gameState === 'play' && (
                                    <div className={`py-12 flex flex-col items-center space-y-8 h-full ${timeLeft === 0 && timerMinutes > 0 ? 'timer-warn' : ''}`}>
                                        {timerMinutes > 0 && <div className="text-6xl font-black px-6 py-2 border-4 border-black neo-box shadow-[8px_8px_0px_0px_rgba(0,0,0,1)]">{formatTime(timeLeft)}</div>}
                                        <h2 className="text-6xl font-black text-red-600 italic animate-bounce uppercase">Diskussion!</h2>
                                        <button onClick={() => setGameState('finish')} className="w-full bg-black text-white py-6 font-black text-2xl neo-box uppercase">Aufl√∂sen</button>
                                    </div>
                                )}

                               {gameState === 'finish' && (
    <div className="py-10 flex flex-col items-center space-y-6 text-center">
        <h2 className="text-2xl font-black uppercase underline decoration-4">
            {gameData.chaosMode === "ALL" ? "PARANOIA! Alle Imposter!" : 
             gameData.chaosMode === "NONE" ? "FEHLALARM! Niemand!" : "Die Verr√§ter:"}
        </h2>
        {gameData.imposterIndices.length > 0 ? gameData.imposterIndices.map(idx => (
            <div key={idx} className="text-4xl font-black text-red-600 italic uppercase tracking-tighter">{players[idx]}</div>
        )) : <div className="text-4xl font-black text-green-600 italic uppercase">Niemand</div>}
        
        {/* HIER DIE √ÑNDERUNG: Zeigt das Thema UND das Wort an */}
        <div className="flex flex-col gap-1 mt-4">
            <div className="text-[10px] font-black uppercase opacity-50">Kategorie: {gameData.topic}</div>
            <div className="text-lg font-bold bg-gray-100 p-4 border-2 border-black uppercase">Das Wort: {gameData.word}</div>
        </div>

        <button onClick={() => {
            const fresh = getShuffledBeliebt(data);
            setShuffledBeliebt(fresh);
            setSubCats(fresh);
            setSelectedGroup("BELIEBT");
            setGameState('setup');
        }} className="w-full bg-red-600 text-white py-5 font-black text-xl neo-box uppercase">
            N√§chste Runde
        </button>
    </div>
)}

                            </div>
                        )}
                    </div> {/* Ende game-card */}

                    {deleteConfirm && (
                        <div className="fixed inset-0 bg-black/90 flex items-center justify-center z-50 p-6">
                            <div className="bg-white border-4 border-black p-6 neo-box w-full max-w-xs text-center space-y-4">
                                <h3 className="font-black text-xl uppercase italic text-black">L√∂schen?</h3>
                                <p className="font-bold text-sm uppercase text-black">"{deleteConfirm}" entfernen?</p>
                                <div className="flex gap-2">
                                    <button onClick={() => setDeleteConfirm(null)} className="flex-1 py-3 border-2 border-black font-black text-xs uppercase text-black">Nein</button>
                                    <button onClick={confirmDelete} className="flex-1 py-3 bg-red-600 text-white border-2 border-black font-black text-xs uppercase">Ja</button>
                                </div>
                            </div>
                        </div>
                    )}
                </div> // Ende main-container
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>