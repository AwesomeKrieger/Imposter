<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<link rel="icon" type="image/png" href="https://raw.githubusercontent.com/AwesomeKrieger/Imposter/refs/heads/main/AppIcon%7Eios-marketing.png">      
<link rel="apple-touch-icon" href="https://raw.githubusercontent.com/AwesomeKrieger/Imposter/refs/heads/main/AppIcon%7Eios-marketing.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <title>IMPOSTER</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
<style>
    :root {
        /* HELLER MODUS */
        --bg-main: #ffffff;
        --bg-card: #ffffff;
        --text-color: #000000;
        --border-color: #000000;
        --item-selected-bg: #000000;
        --item-selected-text: #ffffff;
    }

    /* DARK MODE */
    @media (prefers-color-scheme: dark) {
        :root {
            --bg-main: #000000;
            --bg-card: #000000;
            --text-color: #ffffff;
            --border-color: #ffffff;
            --item-selected-bg: #ffffff;
            --item-selected-text: #000000;
        }
    }

    html, body { 
        background-color: var(--bg-main) !important; 
        color: var(--text-color); 
        margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; 
        transition: background-color 0.3s ease;
    }

    .main-container { 
        height: 100dvh; 
        display: flex; 
        flex-direction: column; 
        padding: 1rem; 
        box-sizing: border-box;
        background-color: var(--bg-main);
    }

    .game-card { 
        background-color: var(--bg-card);
        border: 4px solid var(--border-color) !important;
        display: flex; flex-direction: column; height: 100%; overflow: hidden; 
        box-shadow: 6px 6px 0px 0px var(--border-color);
    }

   .topics-block-container {
    margin: 10px 0;
    border: 4px solid var(--border-color);
    background: var(--bg-card);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 6px 6px 0px 0px var(--border-color);
}

.scroll-container { 
    flex: 1;
    max-height: 280px; /* Begrenzt die H√∂he des Kastens */
    overflow-y: auto !important; 
    background: var(--bg-card); 
    padding: 0 !important;
    display: flex;
    flex-direction: column;
}

.category-item {
    margin: 0 !important;
    padding: 16px; 
    background: var(--bg-card);
    color: var(--text-color);
    border: none !important;
    /* Standardm√§√üig eine dunkle Linie oben zur Trennung */
    border-top: 2px solid var(--border-color) !important; 
    cursor: pointer;
    text-align: left;
    font-weight: 900;
    text-transform: uppercase;
    width: 100% !important;
    box-sizing: border-box;
}
/* Verhindert das Markieren von Text und Elementen */
html, body, #root {
    -webkit-user-select: none; /* Safari */
    -ms-user-select: none;      /* IE 10+ */
    user-select: none;          /* Standard */
    -webkit-touch-callout: none; /* Verhindert das Kontextmen√º auf iOS */
}

/* Erlaubt das Ausw√§hlen nur in Input-Feldern (wichtig f√ºr deinen API-Key!) */
input, textarea {
    -webkit-user-select: text;
    user-select: text;
}


/* WICHTIG: Wenn ausgew√§hlt -> Schwarz mit HELLEM Rand */
.category-item.selected {
    background-color: var(--item-selected-bg) !important;
    color: var(--item-selected-text) !important;
    /* Erzeugt die helle Trennung zwischen zwei schwarzen Bl√∂cken */
    border-top: 2px solid rgba(255, 255, 255, 0.3) !important; 
}

/* Verhindert eine wei√üe Linie beim allerersten Element im Kasten */
.category-item:first-child {
    border-top: none !important;
}


    input, select {
        background-color: var(--bg-card) !important;
        color: var(--text-color) !important;
        border: 2px solid var(--border-color) !important;
    }

    .hide-scrollbar::-webkit-scrollbar { display: none; }
//* GLASSMORPHISM LOOK MIT ABGERUNDETEN ECKEN */
.glass-mode .game-card, 
.glass-mode .topics-block-container {
    background: rgba(255, 255, 255, 0.05) !important;
    backdrop-filter: blur(12px) saturate(160%);
    -webkit-backdrop-filter: blur(12px) saturate(160%);
    border: 1px solid rgba(255, 255, 255, 0.15) !important;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.8) !important;
    
    /* ABGERUNDETE ECKEN */
    border-radius: 24px !important;
}

/* Verhindert, dass die inneren Elemente die Rundung √ºberlagern */
.glass-mode .scroll-container {
    border-radius: 0 0 20px 20px !important;
}

.glass-mode .neo-box { 
    box-shadow: none !important; 
}

.glass-mode .category-item { 
    background: transparent !important; 
    border-top: 1px solid rgba(255, 255, 255, 0.1) !important; 
}

.glass-mode .category-item.selected { 
    background: rgba(255, 255, 255, 0.2) !important; 
    color: #fff !important; 
}


</style>


</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;
       

        const GITHUB_TOPICS_URL = "https://raw.githubusercontent.com/AwesomeKrieger/Imposter/main/topics.json";
        const AI_MODEL = "gemini-2.5-flash-lite"; 


        const App = () => {
            const [data, setData] = useState(null);
            const [aiWordPool, setAiWordPool] = useState(() => {
                const saved = localStorage.getItem('imp_word_pool_v1');
                return saved ? JSON.parse(saved) : {};
            });

            const [groups, setGroups] = useState([]);
            const [selectedGroup, setSelectedGroup] = useState("BELIEBT");
            const [subCats, setSubCats] = useState([]);
            const [selectedSubs, setSelectedSubs] = useState([]);
            
            const [gameState, setGameState] = useState('setup'); 
            const [showBeginner, setShowBeginner] = useState(true);
            const [shuffledBeliebt, setShuffledBeliebt] = useState([]);
            const [players, setPlayers] = useState(['Spieler 1', 'Spieler 2', 'Spieler 3']);
            const [imposterCount, setImposterCount] = useState(1);
            const [showHint, setShowHint] = useState(false);
            const [timerMinutes, setTimerMinutes] = useState(0);
            const [timeLeft, setTimeLeft] = useState(0);
            const [stats, setStats] = useState({});

            const [apiKey, setApiKey] = useState(() => localStorage.getItem('imp_key') || '');
            const [customTopics, setCustomTopics] = useState(() => {
                const saved = localStorage.getItem('imp_custom_v12');
                return saved ? JSON.parse(saved) : [];
            });
            
            const [loading, setLoading] = useState(false);
            const [visualProgress, setVisualProgress] = useState(0);
            const [gameData, setGameData] = useState({ word: "", hint: "", imposterIndices: [], currentPlayer: 0, showingWord: false, chaosMode: "" });
            const [deleteConfirm, setDeleteConfirm] = useState(null);

const triggerDelete = (e, name) => {
    e.preventDefault();
    e.stopPropagation();
    setDeleteConfirm(name);
};
// Effekt f√ºr den 5-Sekunden Beginner-Kasten
useEffect(() => {
    if (gameState === 'play') {
        setShowBeginner(true);
        const timer = setTimeout(() => {
            setShowBeginner(false);
        }, 5000);
        return () => clearTimeout(timer);
    }
}, [gameState]);

// Effekt f√ºr den Countdown-Timer
useEffect(() => {
    let timer;
    if (gameState === 'play' && timeLeft > 0) {
        timer = setInterval(() => {
            setTimeLeft(prev => {
                const next = prev - 1;
                // Hier kannst du die Vibration wieder einf√ºgen:
                if (next >= 0 && next <= 3) window.navigator.vibrate?.(100);
                return next;
            });
        }, 1000);
    }
    return () => clearInterval(timer);
}, [gameState, timeLeft]);

const getFontSize = (text) => {
    if (!text) return 'text-5xl';
    const len = text.length;
    if (len > 15) return 'text-xl';
    if (len > 12) return 'text-2xl';
    if (len > 9) return 'text-3xl';
    if (len > 6) return 'text-4xl';
    return 'text-5xl';
};

const confirmDelete = () => {
    const newList = customTopics.filter(t => t.name !== deleteConfirm);
    setCustomTopics(newList);
    localStorage.setItem('imp_custom_v12', JSON.stringify(newList));
    
    // HIER DIE KORREKTUR: Mit Prefix filtern
    setSelectedSubs(prev => prev.filter(id => id !== `EIGENE:${deleteConfirm}`));
    
    setSubCats(newList.map(t => ({ name: t.name, parent: "EIGENE" })));
    setDeleteConfirm(null);
};



            useEffect(() => {
    fetch(GITHUB_TOPICS_URL)
        .then(res => res.json())
        .then(json => {
            setData(json);
                       
            // KORREKTUR: Gro√ües "O" bei Object und .sort() f√ºr die Reihenfolge
            const sortedJsonGroups = Object.keys(json).sort();
            setGroups(["BELIEBT", "EIGENE", ...sortedJsonGroups]);

            const initial = getShuffledBeliebt(json);
            setShuffledBeliebt(initial);
            setSubCats(initial); 
        })
        .catch(err => console.error("Fehler beim Laden der Themen:", err));
}, []);




            useEffect(() => {
                localStorage.setItem('imp_word_pool_v1', JSON.stringify(aiWordPool));
            }, [aiWordPool]);

            // Hilfsfunktion zum W√ºrfeln (bleibt stabil)
// Hilfsfunktion zum stabilen W√ºrfeln (√§ndert sich alle 3 Stunden)
const getShuffledBeliebt = (fullData) => {
    if (!fullData) return [];
    let list = [];
    Object.keys(fullData).forEach(g => {
        Object.keys(fullData[g]).forEach(s => list.push({ name: s, parent: g }));
    });

    const now = new Date();
    const datePart = now.toISOString().split('T')[0];
    const timeSlot = Math.floor(now.getHours() / 3); 
    const seedString = datePart + "-slot" + timeSlot;

    const seededRandom = (str) => {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return Math.abs(Math.sin(hash));
    };

    return list
        .sort((a, b) => seededRandom(seedString + a.name) - seededRandom(seedString + b.name))
        .slice(0, 6);
};

useEffect(() => {
    let timer;
    if (gameState === 'play' && timeLeft > 0) {
        timer = setInterval(() => {
            setTimeLeft(prev => prev - 1);
        }, 1000);
    } else if (timeLeft === 0 && timerMinutes > 0) {
        // Optional: Sound oder Vibration wenn Zeit abgelaufen
    }
    return () => clearInterval(timer);
}, [gameState, timeLeft, timerMinutes]);



const updateView = (groupName, fullData = data, currentCustom = customTopics) => {
    if (!fullData) return;
    setSelectedGroup(groupName);
    
    if (groupName === "BELIEBT") {
        setSubCats(shuffledBeliebt); // Nutzt die gespeicherten Favoriten
    } else if (groupName === "EIGENE") {
        setSubCats(currentCustom.map(t => ({ name: t.name, parent: "EIGENE" })));
    } else {
        const list = [];
        Object.keys(fullData[groupName]).forEach(s => list.push({ name: s, parent: groupName }));
        setSubCats(list);
    }
};




            const toggleSub = (name, parent) => {
    const id = `${parent}:${name}`; 
    setSelectedSubs(prev => 
        prev.includes(id) ? prev.filter(n => n !== id) : [...prev, id]
    );
};

const selectAll = () => {
    const currentIds = subCats.map(s => `${s.parent}:${s.name}`);
    const allCurrentSelected = currentIds.every(id => selectedSubs.includes(id));
    if (allCurrentSelected) {
        setSelectedSubs(prev => prev.filter(id => !currentIds.includes(id)));
    } else {
        setSelectedSubs(prev => [...new Set([...prev, ...currentIds])]);
    }
};

const handleGlobalToggle = () => {
    if (selectedSubs.length > 0) {
        setSelectedSubs([]);
    } else {
        let allIds = [];
        Object.keys(data).forEach(group => {
            if (group !== "BELIEBT") { // Beliebt √ºberspringen, da es nur Kopien sind
                Object.keys(data[group]).forEach(sub => {
                    allIds.push(`${group}:${sub}`);
                });
            }
        });
        customTopics.forEach(t => allIds.push(`EIGENE:${t.name}`));
        setSelectedSubs(allIds);
    }
};
const [isGlass, setIsGlass] = useState(() => localStorage.getItem('imp_glass') === 'true');

const toggleStyle = () => {
    const next = !isGlass;
    setIsGlass(next);
    localStorage.setItem('imp_glass', next);
};




            const addCustomTopic = () => {
    const name = prompt("Gib ein Thema f√ºr die KI ein:");
    if(name && name.trim() !== "") {
        const trimmedName = name.trim();
        const newList = [...customTopics, { name: trimmedName }];
        setCustomTopics(newList);
        localStorage.setItem('imp_custom_v12', JSON.stringify(newList));
        
        const newSubList = newList.map(t => ({ name: t.name, parent: "EIGENE" }));
        setSubCats(newSubList);
        
        // HIER DIE KORREKTUR: Prefix hinzuf√ºgen
        setSelectedSubs(prev => [...prev, `EIGENE:${trimmedName}`]);
    }
};

const startGame = async () => {
    let finalId = "";
    // 1. Absolute Obergrenze: H√§lfte der Spieler
const limit = Math.floor(players.length / 2);
const maxPossible = Math.min(imposterCount, limit);

// 2. Pool f√ºr gewichteten Zufall (H√∂here Zahlen sind wahrscheinlicher)
const weightPool = [];
for (let i = 1; i <= maxPossible; i++) {
    for (let j = 0; j < (i * 3); j++) { // Faktor 3 f√ºr st√§rkere Gewichtung der hohen Zahl
        weightPool.push(i);
    }
}

// 3. Tats√§chliche Anzahl f√ºr diese Runde w√ºrfeln
const rolledCount = weightPool.length > 0 
    ? weightPool[Math.floor(Math.random() * weightPool.length)] 
    : 1;

// 4. Indizes zuf√§llig zuweisen
let tempIndices = [];
while(tempIndices.length < rolledCount) {
    let r = Math.floor(Math.random() * players.length);
    if(!tempIndices.includes(r)) tempIndices.push(r);
}
indices = tempIndices;


    if (selectedSubs.length === 0) {
        // Sammle ALLE verf√ºgbaren Themen-IDs
        const allPossibleIds = [];
        
        Object.keys(data).forEach(group => {
            if (group !== "BELIEBT") { 
                Object.keys(data[group]).forEach(sub => {
                    allPossibleIds.push(`${group}:${sub}`);
                });
            }
        });
        
        customTopics.forEach(t => allPossibleIds.push(`EIGENE:${t.name}`));

        // W√§hle eine absolut zuf√§llige ID aus der Gesamtliste
        finalId = allPossibleIds[Math.floor(Math.random() * allPossibleIds.length)];
    } else {
        // W√§hle aus deiner Auswahl
        finalId = selectedSubs[Math.floor(Math.random() * selectedSubs.length)];
    }

    if (!finalId) return alert("Keine Themen verf√ºgbar!");

    const [parentGroup, randomSub] = finalId.split(':');

    setLoading(true);
    setVisualProgress(50);
    
    let word = "", hint = "", chaos = "";
    let indices = [];
    


    try {
        
 
        const rng = Math.random();
        if (rng < 0.01) chaos = "ALL";
        else if (rng < 0.02) chaos = "NONE";

        // 3. Nutzt jetzt 'parentGroup', um zu entscheiden: KI oder Liste?
        if (parentGroup === "EIGENE") {
            if(!apiKey) {
                setLoading(false);
                return alert("API Key fehlt!");
            }
            
            if (aiWordPool[randomSub] && aiWordPool[randomSub].length > 0) {
                const nextPair = aiWordPool[randomSub][0];
                word = nextPair.word;
                hint = nextPair.hint;
                setAiWordPool(prev => ({ ...prev, [randomSub]: prev[randomSub].slice(1) }));
            } else {
               

                                                                                               // Der Prompt ist jetzt extrem strikt
                // Optimierter, minimalistischer Prompt
                                // Minimaler User-Prompt
                const promptText = `Thema: "${randomSub}". Erstelle 40 Paare. Verbot: "${randomSub}".`;
                
                const res = await fetch("https://api.groq.com/openai/v1/chat/completions", {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "llama-3.1-8b-instant",
                        messages: [
                            { 
                                role: "system", 
                                content: `Du bist ein Wort-Generator. 
                                Regeln:
                                1. Format: Wort|Hinweis (Beispiel: "Zitrone|Sauer", "Ozean|Blau").
                                2. Der Hinweis muss eine Eigenschaft oder ein Kontext sein, kein Synonym.
                                3. KEIN Einleitungstext. 
                                4. Das Wort "${randomSub}" ist in der gesamten Antwort STRENG VERBOTEN.` 
                            },
                            { role: "user", content: promptText }
                        ],
                        temperature: 0.2, 
                        max_tokens: 800
                    })
                });

                const d = await res.json();
                if (d.error) { alert(`Groq-Fehler: ${d.error.message}`); return; }

                let raw = d.choices[0].message.content.trim();
                raw = raw.replace(/\n/g, ", ").replace(/\d+\./g, "");

                const pairs = raw.split(',').map(p => {
                    const parts = p.split('|');
                    if (parts.length < 2) return null;
                    
                    const w = parts[0].trim();
                    const h = parts[1].trim();
                    const forbidden = randomSub.toLowerCase();
                    
                    // Filter 1: Mindestl√§nge
                    if (w.length < 2) return null;
                    
                    // Filter 2: Verbotenes Thema ausschlie√üen
                    if (w.toLowerCase().includes(forbidden) || h.toLowerCase().includes(forbidden)) return null;
                    
                    // Filter 3: √Ñhnlichkeits-Schutz (verhindert Synonyme/doppelte W√∂rter)
                    // L√∂scht Paare, bei denen das Wort im Hinweis vorkommt oder umgekehrt
                    if (w.toLowerCase().includes(h.toLowerCase()) || h.toLowerCase().includes(w.toLowerCase())) return null;
                    
                    return { word: w, hint: h };
                }).filter(p => p !== null);

                if (pairs.length > 0) {
                    word = pairs[0].word;
                    hint = pairs[0].hint;
                    setAiWordPool(prev => ({ ...prev, [randomSub]: pairs.slice(1) }));
                } else {
                    alert("Formatfehler der KI oder alle Paare gefiltert. Antwort war: " + raw.substring(0, 50));
                }
            }
        } else {
            // Suche global in allen Kategorien von 'data'
            let foundData = null;
            for (let groupKey in data) {
                if (data[groupKey] && data[groupKey][randomSub]) {
                    foundData = data[groupKey][randomSub];
                    break;
                }
            }

            if (foundData && foundData.pairs && foundData.pairs.length > 0) {
                const randomPair = foundData.pairs[Math.floor(Math.random() * foundData.pairs.length)];
                word = randomPair[0];
                hint = randomPair[1];
            }
        }

        if (!word) {
            throw new Error("Wort konnte nicht geladen werden. Thema: " + randomSub);
        }

        if (chaos === "ALL") {
            indices = players.map((_, i) => i);
        } else if (chaos === "NONE") {
            indices = [];
        } else {
            const count = Math.min(imposterCount, players.length - 1);
            while(indices.length < count) {
                let r = Math.floor(Math.random() * players.length);
                if(!indices.includes(r)) indices.push(r);
            }
        }


        const newStats = { ...stats };
        indices.forEach(idx => { newStats[players[idx]] = (newStats[players[idx]] || 0) + 1; });
        setStats(newStats);
        const randomStarter = Math.floor(Math.random() * players.length);

        // √Ñndere diese Zeile in deinem Skript:
setGameData({ word, hint, imposterIndices: indices, currentPlayer: 0, showingWord: false, chaosMode: chaos, topic: randomSub, startingPlayer: randomStarter });
        setTimeLeft(timerMinutes * 60);
        setVisualProgress(100);
        setTimeout(() => { setGameState('reveal'); setLoading(false); }, 400);
    } catch (e) { 
        console.error(e);
        alert("Fehler: " + e.message); 
        setLoading(false); 
    }
};


            const formatTime = (s) => `${Math.floor(s/60)}:${(s%60).toString().padStart(2, '0')}`;

            if (!data) return <div className="h-screen flex items-center justify-center font-black">Lade...</div>;

            return (
               <div className={`main-container ${isGlass ? 'glass-mode' : ''}`}>
    <div className="flex justify-between items-center mb-4 border-b-8 border-red-600">
        <h1 className="text-4xl font-black italic tracking-tighter uppercase">Imposter.ai</h1>
        <button 
            onClick={toggleStyle}
            className="text-[10px] font-black border-2 border-current px-2 py-1 uppercase mb-1"
        >
            {isGlass ? 'Retro' : 'Glass'}
        </button>
    </div>



                    <div className="game-card bg-white p-5 neo-box space-y-4">
                        {loading ? (
                             <div className="flex flex-col items-center justify-center p-10 space-y-4">
                                <div className="font-black text-xl italic uppercase">Generiere...</div>
                                <div className="w-full border-4 border-black h-8 bg-white"><div className="progress-fill" style={{width: `${visualProgress}%`}}></div></div>
                            </div>
                        ) : gameState === 'setup' ? (
                            <>
                                <div className="grid grid-cols-3 gap-2 shrink-0">
                                    <div className="space-y-1">
    <label className="text-[10px] font-black uppercase opacity-60">Verr√§ter :</label>
    <select 
        value={imposterCount} 
        onChange={e => setImposterCount(parseInt(e.target.value))} 
        className="w-full p-2 border-2 border-black font-bold text-xs bg-white outline-none"
    >
        {/* Erzeugt Optionen bis maximal zur H√§lfte der Spieleranzahl */}
        {Array.from({length: Math.floor(players.length / 2)}, (_, i) => i + 1).map(n => (
            <option key={n} value={n}>{n}</option>
        ))}
    </select>
</div>

                                    <div className="space-y-1">
                                        <label className="text-[10px] font-black uppercase opacity-60">Hinweis:</label>
                                        <button onClick={() => setShowHint(!showHint)} className={`w-full p-2 border-2 border-black font-bold text-[10px] uppercase transition-colors ${showHint ? 'bg-green-400' : 'bg-red-400'}`}>
                                            {showHint ? 'AN' : 'AUS'}
                                        </button>
                                    </div>
                                    <div className="space-y-1">
                                        <label className="text-[10px] font-black uppercase opacity-60">Zeitlimit:</label>
                                        <select value={timerMinutes} onChange={e => setTimerMinutes(parseInt(e.target.value))} className="w-full p-2 border-2 border-black font-bold text-xs bg-white outline-none">
                                            {[0,1,2,3,5,10].map(m => <option key={m} value={m}>{m === 0 ? "AUS" : `${m}min`}</option>)}
                                        </select>
                                    </div>
                                </div>

                                <div className="space-y-2 pt-2 shrink-0">
                                    <div className="flex justify-between items-center">
                                        <span className="font-black text-[10px] uppercase underline">Mitspieler:</span>
                                        <button onClick={() => players.length < 10 && setPlayers([...players, `Spieler ${players.length+1}`])} className="bg-green-500 text-white px-2 py-1 neo-box text-[10px] font-black uppercase">+ Add</button>
                                    </div>
                                    <div className="grid grid-cols-2 gap-1 max-h-24 overflow-y-auto border border-black p-1 bg-gray-50">
                                        {players.map((p, i) => (
                                            <div key={i} className="flex border border-black bg-white">
                                                <input value={p} onChange={e => {let n=[...players]; n[i]=e.target.value; setPlayers(n);}} className="w-full p-1 text-[10px] font-bold outline-none uppercase" />
                                                <span className="text-[9px] font-black bg-yellow-400 px-1 border-l border-black flex items-center">üïµÔ∏è{stats[p] || 0}</span>
                                                <button onClick={() => players.length > 3 && setPlayers(players.filter((_, idx) => idx !== i))} className="bg-red-500 text-white px-1 font-black">√ó</button>
                                            </div>
                                        ))}
                                    </div>
                                </div>

                              <div className="flex gap-2 overflow-x-auto pb-2 hide-scrollbar border-t-2 border-black pt-2 shrink-0">
    {groups.map(g => {
        let hasSelection = false;
        let countInGroup = 0;

        if (g === "BELIEBT") {
            const beliebtIds = shuffledBeliebt.map(s => `${s.parent}:${s.name}`);
            countInGroup = selectedSubs.filter(id => beliebtIds.includes(id)).length;
            hasSelection = countInGroup > 0;
        } else {
            hasSelection = selectedSubs.some(id => id.startsWith(`${g}:`));
            countInGroup = selectedSubs.filter(id => id.startsWith(`${g}:`)).length;
        }

        // KONSTANTE zum Trimmen der Zahlen am Anfang
        const displayName = g.replace(/^[\d.]+\s*/, "");

        return (
            <button 
                key={g} 
                onClick={() => updateView(g)} 
                className={`px-3 py-2 border-2 border-black font-black text-[10px] uppercase whitespace-nowrap transition-all 
                    ${selectedGroup === g ? 'bg-red-600 text-white' : (hasSelection ? 'bg-yellow-300 text-black' : 'bg-white text-black')}`}
            >
                {/* KORREKTUR: Hier muss displayName stehen statt g */}
                {displayName} {hasSelection && `(${countInGroup})`}
            </button>
        );
    })}
</div>



                                <div className="topics-block-container mx-0 my-2">
    {/* Buttons b√ºndig oben im Kasten */}
    <div className="flex shrink-0 bg-transparent border-b-4 border-black dark:border-white">
       <button 
    onClick={selectAll} 
    className="flex-1 p-3 bg-yellow-400 font-black text-[10px] uppercase !text-black border-r-4 border-black dark:border-white active:bg-yellow-500 transition-colors"
>
    {subCats.length > 0 && subCats.every(s => selectedSubs.includes(`${s.parent}:${s.name}`)) 
        ? "√ó Abw√§hlen" 
        : "‚úì Gruppe"}
</button>


        <button 
    onClick={handleGlobalToggle} 
    className={`w-1/3 p-3 font-black text-[10px] uppercase transition-colors ${
        selectedSubs.length > 0 ? 'bg-red-500 text-white' : 'bg-blue-500 text-white'
    }`}
>
    {selectedSubs.length > 0 ? `Reset (${selectedSubs.length})` : "Global"}
</button>

    </div>

    {/* Themenliste direkt darunter im selben Geh√§use */}
    <div className="scroll-container hide-scrollbar" style={{ maxHeight: '300px' }}>
        {selectedGroup === "EIGENE" && (
            <button 
                onClick={addCustomTopic} 
                className="w-full p-4 border-b-4 border-dashed border-black dark:border-white font-black text-sm uppercase bg-yellow-100 !text-black shrink-0"
            >
                + NEUES KI-THEMA
            </button>
        )}
        
        {subCats.map((s) => {
    const currentId = `${s.parent}:${s.name}`; // Nutzt jetzt den echten Ursprung
    const isSelected = selectedSubs.includes(currentId);
    return (
        <button 
            key={currentId}
            type="button"
            onClick={() => toggleSub(s.name, s.parent)} 
            className={`category-item ${isSelected ? 'selected' : ''}`}
        >
            <div className="flex justify-between items-center w-full">
                <span>{isSelected ? "‚úì " : ""}{s.name}</span>
                {selectedGroup === "EIGENE" && (
                    <span 
                        onClick={(e) => { e.stopPropagation(); triggerDelete(e, s.name); }} 
                        className="text-[10px] bg-red-600 px-2 py-1 text-white border-2 border-white font-black"
                    >
                        L√ñSCHEN
                    </span>
                )}
            </div>
        </button>
    );
})}

    </div>
</div>

<button onClick={startGame} className="w-full bg-red-600 text-white font-black py-4 text-2xl neo-box shrink-0 active:bg-red-700 uppercase shadow-[8px_8px_0px_0px_rgba(0,0,0,1)] glass-target">
    {selectedSubs.length > 0 ? `Start (${selectedSubs.length})` : 'Zuf√§lliges Thema'}
</button>


                                <input type="password" placeholder="API Key..." className="w-full p-1 text-[8px] border-b opacity-10 shrink-0" value={apiKey} onChange={e => {setApiKey(e.target.value); localStorage.setItem('imp_key', e.target.value);}} />
                            </>                                                 ) : (
                            <div className="p-4 text-center">
                                {gameState === 'reveal' && (
                                    <div className="space-y-6 py-4 flex flex-col items-center">
                                        <h2 className="text-2xl font-black uppercase italic border-b-4 border-black px-4">
                                            {players[gameData.currentPlayer]}
                                        </h2>
                                        
                                        <div onClick={() => setGameData({...gameData, showingWord: true})} 
                                             className={`w-full h-64 flex flex-col items-center justify-center border-4 border-black p-6 
                                             ${gameData.showingWord 
                                                ? (gameData.imposterIndices.includes(gameData.currentPlayer) ? 'bg-black text-white' : 'bg-red-600 text-white') 
                                                : 'bg-gray-100 animate-pulse'}`}>
                                            
                                            {gameData.showingWord ? (
                                                gameData.imposterIndices.includes(gameData.currentPlayer) ? (
                                                    <div className="text-center">
                                                        <div className="text-red-500 font-black text-xl mb-1 uppercase tracking-widest">Du bist der</div>
                                                        <div className="text-6xl font-black uppercase italic">Imposter</div>
                                                        {showHint && <div className="mt-6 p-3 border-2 border-white text-sm font-bold uppercase tracking-tight">Tipp: {gameData.hint}</div>}
                                                    </div>
                                                ) : (
                                                    <span className={`${getFontSize(gameData.word)} font-black uppercase tracking-tighter text-center break-words w-full px-2`}>
                                                        {gameData.word}
                                                    </span>
                                                )
                                            ) : (
                                                <span className="text-2xl font-black italic underline uppercase text-black">Karte aufdecken</span>
                                            )}
                                        </div>

                                        {gameData.showingWord && (
                                            <button onClick={() => {
                                                if(gameData.currentPlayer + 1 < players.length) {
                                                    setGameData({...gameData, currentPlayer: gameData.currentPlayer + 1, showingWord: false});
                                                } else {
                                                    setGameState('play');
                                                }
                                            }} className="w-full bg-black text-white py-4 font-black text-xl neo-box uppercase shadow-[8px_8px_0px_0px_rgba(0,0,0,1)]
">
                                                Verstanden
                                            </button>
                                        )}
                                    </div>
                                )}

                             {gameState === 'play' && (
    <div className={`py-8 flex flex-col items-center space-y-6 h-full ${timeLeft === 0 && timerMinutes > 0 ? 'animate-pulse' : ''}`}>
        
        {/* Timer Anzeige */}
        {timerMinutes > 0 && (
            <div className={`text-6xl font-black px-6 py-2 border-4 border-black neo-box shadow-[8px_8px_0px_0px_rgba(0,0,0,1)] glass-target ${timeLeft < 10 ? 'text-red-600 border-red-600' : ''}`}>
                {formatTime(timeLeft)}
            </div>
        )}

        {/* Startspieler Anzeige - Verschwindet nach 5 Sekunden mit Animation */}
        <div className={`w-full transition-all duration-500 overflow-hidden ${showBeginner ? 'max-h-40 opacity-100 mb-4' : 'max-h-0 opacity-0 mb-0'}`}>
            <div className="bg-yellow-300 border-4 border-black p-5 neo-box glass-target">
                <p className="text-[10px] font-black uppercase opacity-60 tracking-widest">Die Runde er√∂ffnet:</p>
                <h3 className="text-3xl font-black uppercase italic flex items-center gap-3 text-black">
            
            {players[gameData.startingPlayer]}
                </h3>
            </div>
        </div>

        {/* Titel & Info */}
        <div className="text-center space-y-2 py-4">
            <h2 className="text-6xl font-black text-red-600 italic animate-bounce uppercase tracking-tighter">
                Diskussion!
            </h2>
            <div className="font-bold text-[10px] uppercase opacity-50">
                <span>Entlarvt den Verr√§ter</span>
                {timerMinutes > 0 && timeLeft > 0 && <span>, bevor die Zeit abl√§uft</span>}
                <span>.</span>
            </div>
        </div>

       {/* Button zum Beenden mit Schatten */}
<button 
    onClick={() => setGameState('finish')} 
    className="w-full bg-black text-white py-6 font-black text-2xl neo-box uppercase active:scale-95 active:shadow-none transition-all shadow-[8px_8px_0px_0px_rgba(0,0,0,1)] glass-target"
>
    Aufl√∂sen
</button>

    </div>
)}




                               {gameState === 'finish' && (
    <div className="py-10 flex flex-col items-center space-y-6 text-center">
        <h2 className="text-2xl font-black uppercase underline decoration-4">
            {gameData.chaosMode === "ALL" ? "PARANOIA! Alle Imposter!" : 
             gameData.chaosMode === "NONE" ? "FEHLALARM! Niemand!" : "Die Verr√§ter:"}
        </h2>
        {gameData.imposterIndices.length > 0 ? gameData.imposterIndices.map(idx => (
            <div key={idx} className="text-4xl font-black text-red-600 italic uppercase tracking-tighter">{players[idx]}</div>
        )) : <div className="text-4xl font-black text-green-600 italic uppercase">Niemand</div>}
        
        {/* HIER DIE √ÑNDERUNG: Zeigt das Thema UND das Wort an */}
        <div className="flex flex-col gap-1 mt-4">
            <div className="text-[10px] font-black uppercase opacity-50">Kategorie: {gameData.topic}</div>
            <div className="text-lg font-bold bg-gray-100 p-4 border-2 border-black uppercase">Das Wort: {gameData.word}</div>
        </div>

        <button onClick={() => {
            const fresh = getShuffledBeliebt(data);
            setShuffledBeliebt(fresh);
            setSubCats(fresh);
            setSelectedGroup("BELIEBT");
            setGameState('setup');
        }} className="w-full bg-red-600 text-white py-5 font-black text-xl neo-box uppercase">
            N√§chste Runde
        </button>
    </div>
)}

                            </div>
                        )}
                    </div> {/* Ende game-card */}

                    {deleteConfirm && (
                        <div className="fixed inset-0 bg-black/90 flex items-center justify-center z-50 p-6">
                            <div className="bg-white border-4 border-black p-6 neo-box w-full max-w-xs text-center space-y-4">
                                <h3 className="font-black text-xl uppercase italic text-black">L√∂schen?</h3>
                                <p className="font-bold text-sm uppercase text-black">"{deleteConfirm}" entfernen?</p>
                                <div className="flex gap-2">
                                    <button onClick={() => setDeleteConfirm(null)} className="flex-1 py-3 border-2 border-black font-black text-xs uppercase text-black">Nein</button>
                                    <button onClick={confirmDelete} className="flex-1 py-3 bg-red-600 text-white border-2 border-black font-black text-xs uppercase">Ja</button>
                                </div>
                            </div>
                        </div>
                    )}
                </div> // Ende main-container
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>